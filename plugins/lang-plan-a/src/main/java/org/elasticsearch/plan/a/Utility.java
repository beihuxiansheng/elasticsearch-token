begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|org.elasticsearch.plan.a
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|plan
operator|.
name|a
package|;
end_package

begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_class
DECL|class|Utility
specifier|public
class|class
name|Utility
block|{
DECL|method|NumberToboolean
specifier|public
specifier|static
name|boolean
name|NumberToboolean
parameter_list|(
specifier|final
name|Number
name|value
parameter_list|)
block|{
return|return
name|value
operator|.
name|longValue
argument_list|()
operator|!=
literal|0
return|;
block|}
DECL|method|NumberTochar
specifier|public
specifier|static
name|char
name|NumberTochar
parameter_list|(
specifier|final
name|Number
name|value
parameter_list|)
block|{
return|return
operator|(
name|char
operator|)
name|value
operator|.
name|intValue
argument_list|()
return|;
block|}
DECL|method|NumberToBoolean
specifier|public
specifier|static
name|Boolean
name|NumberToBoolean
parameter_list|(
specifier|final
name|Number
name|value
parameter_list|)
block|{
return|return
name|value
operator|.
name|longValue
argument_list|()
operator|!=
literal|0
return|;
block|}
DECL|method|NumberToByte
specifier|public
specifier|static
name|Byte
name|NumberToByte
parameter_list|(
specifier|final
name|Number
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|null
else|:
name|value
operator|.
name|byteValue
argument_list|()
return|;
block|}
DECL|method|NumberToShort
specifier|public
specifier|static
name|Short
name|NumberToShort
parameter_list|(
specifier|final
name|Number
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|null
else|:
name|value
operator|.
name|shortValue
argument_list|()
return|;
block|}
DECL|method|NumberToCharacter
specifier|public
specifier|static
name|Character
name|NumberToCharacter
parameter_list|(
specifier|final
name|Number
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|char
operator|)
name|value
operator|.
name|intValue
argument_list|()
return|;
block|}
DECL|method|NumberToInteger
specifier|public
specifier|static
name|Integer
name|NumberToInteger
parameter_list|(
specifier|final
name|Number
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|null
else|:
name|value
operator|.
name|intValue
argument_list|()
return|;
block|}
DECL|method|NumberToLong
specifier|public
specifier|static
name|Long
name|NumberToLong
parameter_list|(
specifier|final
name|Number
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|null
else|:
name|value
operator|.
name|longValue
argument_list|()
return|;
block|}
DECL|method|NumberToFloat
specifier|public
specifier|static
name|Float
name|NumberToFloat
parameter_list|(
specifier|final
name|Number
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|null
else|:
name|value
operator|.
name|floatValue
argument_list|()
return|;
block|}
DECL|method|NumberToDouble
specifier|public
specifier|static
name|Double
name|NumberToDouble
parameter_list|(
specifier|final
name|Number
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|null
else|:
name|value
operator|.
name|doubleValue
argument_list|()
return|;
block|}
DECL|method|booleanTobyte
specifier|public
specifier|static
name|byte
name|booleanTobyte
parameter_list|(
specifier|final
name|boolean
name|value
parameter_list|)
block|{
return|return
call|(
name|byte
call|)
argument_list|(
name|value
condition|?
literal|1
else|:
literal|0
argument_list|)
return|;
block|}
DECL|method|booleanToshort
specifier|public
specifier|static
name|short
name|booleanToshort
parameter_list|(
specifier|final
name|boolean
name|value
parameter_list|)
block|{
return|return
call|(
name|short
call|)
argument_list|(
name|value
condition|?
literal|1
else|:
literal|0
argument_list|)
return|;
block|}
DECL|method|booleanTochar
specifier|public
specifier|static
name|char
name|booleanTochar
parameter_list|(
specifier|final
name|boolean
name|value
parameter_list|)
block|{
return|return
call|(
name|char
call|)
argument_list|(
name|value
condition|?
literal|1
else|:
literal|0
argument_list|)
return|;
block|}
DECL|method|booleanToint
specifier|public
specifier|static
name|int
name|booleanToint
parameter_list|(
specifier|final
name|boolean
name|value
parameter_list|)
block|{
return|return
name|value
condition|?
literal|1
else|:
literal|0
return|;
block|}
DECL|method|booleanTolong
specifier|public
specifier|static
name|long
name|booleanTolong
parameter_list|(
specifier|final
name|boolean
name|value
parameter_list|)
block|{
return|return
name|value
condition|?
literal|1
else|:
literal|0
return|;
block|}
DECL|method|booleanTofloat
specifier|public
specifier|static
name|float
name|booleanTofloat
parameter_list|(
specifier|final
name|boolean
name|value
parameter_list|)
block|{
return|return
name|value
condition|?
literal|1
else|:
literal|0
return|;
block|}
DECL|method|booleanTodouble
specifier|public
specifier|static
name|double
name|booleanTodouble
parameter_list|(
specifier|final
name|boolean
name|value
parameter_list|)
block|{
return|return
name|value
condition|?
literal|1
else|:
literal|0
return|;
block|}
DECL|method|booleanToInteger
specifier|public
specifier|static
name|Integer
name|booleanToInteger
parameter_list|(
specifier|final
name|boolean
name|value
parameter_list|)
block|{
return|return
name|value
condition|?
literal|1
else|:
literal|0
return|;
block|}
DECL|method|BooleanTobyte
specifier|public
specifier|static
name|byte
name|BooleanTobyte
parameter_list|(
specifier|final
name|Boolean
name|value
parameter_list|)
block|{
return|return
call|(
name|byte
call|)
argument_list|(
name|value
condition|?
literal|1
else|:
literal|0
argument_list|)
return|;
block|}
DECL|method|BooleanToshort
specifier|public
specifier|static
name|short
name|BooleanToshort
parameter_list|(
specifier|final
name|Boolean
name|value
parameter_list|)
block|{
return|return
call|(
name|short
call|)
argument_list|(
name|value
condition|?
literal|1
else|:
literal|0
argument_list|)
return|;
block|}
DECL|method|BooleanTochar
specifier|public
specifier|static
name|char
name|BooleanTochar
parameter_list|(
specifier|final
name|Boolean
name|value
parameter_list|)
block|{
return|return
call|(
name|char
call|)
argument_list|(
name|value
condition|?
literal|1
else|:
literal|0
argument_list|)
return|;
block|}
DECL|method|BooleanToint
specifier|public
specifier|static
name|int
name|BooleanToint
parameter_list|(
specifier|final
name|Boolean
name|value
parameter_list|)
block|{
return|return
name|value
condition|?
literal|1
else|:
literal|0
return|;
block|}
DECL|method|BooleanTolong
specifier|public
specifier|static
name|long
name|BooleanTolong
parameter_list|(
specifier|final
name|Boolean
name|value
parameter_list|)
block|{
return|return
name|value
condition|?
literal|1
else|:
literal|0
return|;
block|}
DECL|method|BooleanTofloat
specifier|public
specifier|static
name|float
name|BooleanTofloat
parameter_list|(
specifier|final
name|Boolean
name|value
parameter_list|)
block|{
return|return
name|value
condition|?
literal|1
else|:
literal|0
return|;
block|}
DECL|method|BooleanTodouble
specifier|public
specifier|static
name|double
name|BooleanTodouble
parameter_list|(
specifier|final
name|Boolean
name|value
parameter_list|)
block|{
return|return
name|value
condition|?
literal|1
else|:
literal|0
return|;
block|}
DECL|method|BooleanToByte
specifier|public
specifier|static
name|Byte
name|BooleanToByte
parameter_list|(
specifier|final
name|Boolean
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|null
else|:
call|(
name|byte
call|)
argument_list|(
name|value
condition|?
literal|1
else|:
literal|0
argument_list|)
return|;
block|}
DECL|method|BooleanToShort
specifier|public
specifier|static
name|Short
name|BooleanToShort
parameter_list|(
specifier|final
name|Boolean
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|null
else|:
call|(
name|short
call|)
argument_list|(
name|value
condition|?
literal|1
else|:
literal|0
argument_list|)
return|;
block|}
DECL|method|BooleanToCharacter
specifier|public
specifier|static
name|Character
name|BooleanToCharacter
parameter_list|(
specifier|final
name|Boolean
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|null
else|:
call|(
name|char
call|)
argument_list|(
name|value
condition|?
literal|1
else|:
literal|0
argument_list|)
return|;
block|}
DECL|method|BooleanToInteger
specifier|public
specifier|static
name|Integer
name|BooleanToInteger
parameter_list|(
specifier|final
name|Boolean
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|null
else|:
name|value
condition|?
literal|1
else|:
literal|0
return|;
block|}
DECL|method|BooleanToLong
specifier|public
specifier|static
name|Long
name|BooleanToLong
parameter_list|(
specifier|final
name|Boolean
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|null
else|:
name|value
condition|?
literal|1L
else|:
literal|0L
return|;
block|}
DECL|method|BooleanToFloat
specifier|public
specifier|static
name|Float
name|BooleanToFloat
parameter_list|(
specifier|final
name|Boolean
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|null
else|:
name|value
condition|?
literal|1F
else|:
literal|0F
return|;
block|}
DECL|method|BooleanToDouble
specifier|public
specifier|static
name|Double
name|BooleanToDouble
parameter_list|(
specifier|final
name|Boolean
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|null
else|:
name|value
condition|?
literal|1D
else|:
literal|0D
return|;
block|}
DECL|method|byteToboolean
specifier|public
specifier|static
name|boolean
name|byteToboolean
parameter_list|(
specifier|final
name|byte
name|value
parameter_list|)
block|{
return|return
name|value
operator|!=
literal|0
return|;
block|}
DECL|method|byteToShort
specifier|public
specifier|static
name|Short
name|byteToShort
parameter_list|(
specifier|final
name|byte
name|value
parameter_list|)
block|{
return|return
operator|(
name|short
operator|)
name|value
return|;
block|}
DECL|method|byteToCharacter
specifier|public
specifier|static
name|Character
name|byteToCharacter
parameter_list|(
specifier|final
name|byte
name|value
parameter_list|)
block|{
return|return
call|(
name|char
call|)
argument_list|(
name|byte
argument_list|)
name|value
return|;
block|}
DECL|method|byteToInteger
specifier|public
specifier|static
name|Integer
name|byteToInteger
parameter_list|(
specifier|final
name|byte
name|value
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|value
return|;
block|}
DECL|method|byteToLong
specifier|public
specifier|static
name|Long
name|byteToLong
parameter_list|(
specifier|final
name|byte
name|value
parameter_list|)
block|{
return|return
operator|(
name|long
operator|)
name|value
return|;
block|}
DECL|method|byteToFloat
specifier|public
specifier|static
name|Float
name|byteToFloat
parameter_list|(
specifier|final
name|byte
name|value
parameter_list|)
block|{
return|return
operator|(
name|float
operator|)
name|value
return|;
block|}
DECL|method|byteToDouble
specifier|public
specifier|static
name|Double
name|byteToDouble
parameter_list|(
specifier|final
name|byte
name|value
parameter_list|)
block|{
return|return
operator|(
name|double
operator|)
name|value
return|;
block|}
DECL|method|ByteToboolean
specifier|public
specifier|static
name|boolean
name|ByteToboolean
parameter_list|(
specifier|final
name|Byte
name|value
parameter_list|)
block|{
return|return
name|value
operator|!=
literal|0
return|;
block|}
DECL|method|ByteTochar
specifier|public
specifier|static
name|char
name|ByteTochar
parameter_list|(
specifier|final
name|Byte
name|value
parameter_list|)
block|{
return|return
operator|(
name|char
operator|)
name|value
operator|.
name|byteValue
argument_list|()
return|;
block|}
DECL|method|shortToboolean
specifier|public
specifier|static
name|boolean
name|shortToboolean
parameter_list|(
specifier|final
name|short
name|value
parameter_list|)
block|{
return|return
name|value
operator|!=
literal|0
return|;
block|}
DECL|method|shortToByte
specifier|public
specifier|static
name|Byte
name|shortToByte
parameter_list|(
specifier|final
name|short
name|value
parameter_list|)
block|{
return|return
operator|(
name|byte
operator|)
name|value
return|;
block|}
DECL|method|shortToCharacter
specifier|public
specifier|static
name|Character
name|shortToCharacter
parameter_list|(
specifier|final
name|short
name|value
parameter_list|)
block|{
return|return
call|(
name|char
call|)
argument_list|(
name|short
argument_list|)
name|value
return|;
block|}
DECL|method|shortToInteger
specifier|public
specifier|static
name|Integer
name|shortToInteger
parameter_list|(
specifier|final
name|short
name|value
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|value
return|;
block|}
DECL|method|shortToLong
specifier|public
specifier|static
name|Long
name|shortToLong
parameter_list|(
specifier|final
name|short
name|value
parameter_list|)
block|{
return|return
operator|(
name|long
operator|)
name|value
return|;
block|}
DECL|method|shortToFloat
specifier|public
specifier|static
name|Float
name|shortToFloat
parameter_list|(
specifier|final
name|short
name|value
parameter_list|)
block|{
return|return
operator|(
name|float
operator|)
name|value
return|;
block|}
DECL|method|shortToDouble
specifier|public
specifier|static
name|Double
name|shortToDouble
parameter_list|(
specifier|final
name|short
name|value
parameter_list|)
block|{
return|return
operator|(
name|double
operator|)
name|value
return|;
block|}
DECL|method|ShortToboolean
specifier|public
specifier|static
name|boolean
name|ShortToboolean
parameter_list|(
specifier|final
name|Short
name|value
parameter_list|)
block|{
return|return
name|value
operator|!=
literal|0
return|;
block|}
DECL|method|ShortTochar
specifier|public
specifier|static
name|char
name|ShortTochar
parameter_list|(
specifier|final
name|Short
name|value
parameter_list|)
block|{
return|return
operator|(
name|char
operator|)
name|value
operator|.
name|shortValue
argument_list|()
return|;
block|}
DECL|method|charToboolean
specifier|public
specifier|static
name|boolean
name|charToboolean
parameter_list|(
specifier|final
name|char
name|value
parameter_list|)
block|{
return|return
name|value
operator|!=
literal|0
return|;
block|}
DECL|method|charToByte
specifier|public
specifier|static
name|Byte
name|charToByte
parameter_list|(
specifier|final
name|char
name|value
parameter_list|)
block|{
return|return
operator|(
name|byte
operator|)
name|value
return|;
block|}
DECL|method|charToShort
specifier|public
specifier|static
name|Short
name|charToShort
parameter_list|(
specifier|final
name|char
name|value
parameter_list|)
block|{
return|return
operator|(
name|short
operator|)
name|value
return|;
block|}
DECL|method|charToInteger
specifier|public
specifier|static
name|Integer
name|charToInteger
parameter_list|(
specifier|final
name|char
name|value
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|value
return|;
block|}
DECL|method|charToLong
specifier|public
specifier|static
name|Long
name|charToLong
parameter_list|(
specifier|final
name|char
name|value
parameter_list|)
block|{
return|return
operator|(
name|long
operator|)
name|value
return|;
block|}
DECL|method|charToFloat
specifier|public
specifier|static
name|Float
name|charToFloat
parameter_list|(
specifier|final
name|char
name|value
parameter_list|)
block|{
return|return
operator|(
name|float
operator|)
name|value
return|;
block|}
DECL|method|charToDouble
specifier|public
specifier|static
name|Double
name|charToDouble
parameter_list|(
specifier|final
name|char
name|value
parameter_list|)
block|{
return|return
operator|(
name|double
operator|)
name|value
return|;
block|}
DECL|method|CharacterToboolean
specifier|public
specifier|static
name|boolean
name|CharacterToboolean
parameter_list|(
specifier|final
name|Character
name|value
parameter_list|)
block|{
return|return
name|value
operator|!=
literal|0
return|;
block|}
DECL|method|CharacterTobyte
specifier|public
specifier|static
name|byte
name|CharacterTobyte
parameter_list|(
specifier|final
name|Character
name|value
parameter_list|)
block|{
return|return
operator|(
name|byte
operator|)
name|value
operator|.
name|charValue
argument_list|()
return|;
block|}
DECL|method|CharacterToshort
specifier|public
specifier|static
name|short
name|CharacterToshort
parameter_list|(
specifier|final
name|Character
name|value
parameter_list|)
block|{
return|return
operator|(
name|short
operator|)
name|value
operator|.
name|charValue
argument_list|()
return|;
block|}
DECL|method|CharacterToint
specifier|public
specifier|static
name|int
name|CharacterToint
parameter_list|(
specifier|final
name|Character
name|value
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|value
return|;
block|}
DECL|method|CharacterTolong
specifier|public
specifier|static
name|long
name|CharacterTolong
parameter_list|(
specifier|final
name|Character
name|value
parameter_list|)
block|{
return|return
operator|(
name|long
operator|)
name|value
return|;
block|}
DECL|method|CharacterTofloat
specifier|public
specifier|static
name|float
name|CharacterTofloat
parameter_list|(
specifier|final
name|Character
name|value
parameter_list|)
block|{
return|return
operator|(
name|float
operator|)
name|value
return|;
block|}
DECL|method|CharacterTodouble
specifier|public
specifier|static
name|double
name|CharacterTodouble
parameter_list|(
specifier|final
name|Character
name|value
parameter_list|)
block|{
return|return
operator|(
name|double
operator|)
name|value
return|;
block|}
DECL|method|CharacterToBoolean
specifier|public
specifier|static
name|Boolean
name|CharacterToBoolean
parameter_list|(
specifier|final
name|Character
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|null
else|:
name|value
operator|!=
literal|0
return|;
block|}
DECL|method|CharacterToByte
specifier|public
specifier|static
name|Byte
name|CharacterToByte
parameter_list|(
specifier|final
name|Character
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|byte
operator|)
name|value
operator|.
name|charValue
argument_list|()
return|;
block|}
DECL|method|CharacterToShort
specifier|public
specifier|static
name|Short
name|CharacterToShort
parameter_list|(
specifier|final
name|Character
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|short
operator|)
name|value
operator|.
name|charValue
argument_list|()
return|;
block|}
DECL|method|CharacterToInteger
specifier|public
specifier|static
name|Integer
name|CharacterToInteger
parameter_list|(
specifier|final
name|Character
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|int
operator|)
name|value
return|;
block|}
DECL|method|CharacterToLong
specifier|public
specifier|static
name|Long
name|CharacterToLong
parameter_list|(
specifier|final
name|Character
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|long
operator|)
name|value
return|;
block|}
DECL|method|CharacterToFloat
specifier|public
specifier|static
name|Float
name|CharacterToFloat
parameter_list|(
specifier|final
name|Character
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|float
operator|)
name|value
return|;
block|}
DECL|method|CharacterToDouble
specifier|public
specifier|static
name|Double
name|CharacterToDouble
parameter_list|(
specifier|final
name|Character
name|value
parameter_list|)
block|{
return|return
name|value
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|double
operator|)
name|value
return|;
block|}
DECL|method|intToboolean
specifier|public
specifier|static
name|boolean
name|intToboolean
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
block|{
return|return
name|value
operator|!=
literal|0
return|;
block|}
DECL|method|intToByte
specifier|public
specifier|static
name|Byte
name|intToByte
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
block|{
return|return
operator|(
name|byte
operator|)
name|value
return|;
block|}
DECL|method|intToShort
specifier|public
specifier|static
name|Short
name|intToShort
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
block|{
return|return
operator|(
name|short
operator|)
name|value
return|;
block|}
DECL|method|intToCharacter
specifier|public
specifier|static
name|Character
name|intToCharacter
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
block|{
return|return
call|(
name|char
call|)
argument_list|(
name|int
argument_list|)
name|value
return|;
block|}
DECL|method|intToLong
specifier|public
specifier|static
name|Long
name|intToLong
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
block|{
return|return
operator|(
name|long
operator|)
name|value
return|;
block|}
DECL|method|intToFloat
specifier|public
specifier|static
name|Float
name|intToFloat
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
block|{
return|return
operator|(
name|float
operator|)
name|value
return|;
block|}
DECL|method|intToDouble
specifier|public
specifier|static
name|Double
name|intToDouble
parameter_list|(
specifier|final
name|int
name|value
parameter_list|)
block|{
return|return
operator|(
name|double
operator|)
name|value
return|;
block|}
DECL|method|IntegerToboolean
specifier|public
specifier|static
name|boolean
name|IntegerToboolean
parameter_list|(
specifier|final
name|Integer
name|value
parameter_list|)
block|{
return|return
name|value
operator|!=
literal|0
return|;
block|}
DECL|method|IntegerTochar
specifier|public
specifier|static
name|char
name|IntegerTochar
parameter_list|(
specifier|final
name|Integer
name|value
parameter_list|)
block|{
return|return
operator|(
name|char
operator|)
name|value
operator|.
name|intValue
argument_list|()
return|;
block|}
DECL|method|longToboolean
specifier|public
specifier|static
name|boolean
name|longToboolean
parameter_list|(
specifier|final
name|long
name|value
parameter_list|)
block|{
return|return
name|value
operator|!=
literal|0
return|;
block|}
DECL|method|longToByte
specifier|public
specifier|static
name|Byte
name|longToByte
parameter_list|(
specifier|final
name|long
name|value
parameter_list|)
block|{
return|return
operator|(
name|byte
operator|)
name|value
return|;
block|}
DECL|method|longToShort
specifier|public
specifier|static
name|Short
name|longToShort
parameter_list|(
specifier|final
name|long
name|value
parameter_list|)
block|{
return|return
operator|(
name|short
operator|)
name|value
return|;
block|}
DECL|method|longToCharacter
specifier|public
specifier|static
name|Character
name|longToCharacter
parameter_list|(
specifier|final
name|long
name|value
parameter_list|)
block|{
return|return
call|(
name|char
call|)
argument_list|(
name|long
argument_list|)
name|value
return|;
block|}
DECL|method|longToInteger
specifier|public
specifier|static
name|Integer
name|longToInteger
parameter_list|(
specifier|final
name|long
name|value
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|value
return|;
block|}
DECL|method|longToFloat
specifier|public
specifier|static
name|Float
name|longToFloat
parameter_list|(
specifier|final
name|long
name|value
parameter_list|)
block|{
return|return
operator|(
name|float
operator|)
name|value
return|;
block|}
DECL|method|longToDouble
specifier|public
specifier|static
name|Double
name|longToDouble
parameter_list|(
specifier|final
name|long
name|value
parameter_list|)
block|{
return|return
operator|(
name|double
operator|)
name|value
return|;
block|}
DECL|method|LongToboolean
specifier|public
specifier|static
name|boolean
name|LongToboolean
parameter_list|(
specifier|final
name|Long
name|value
parameter_list|)
block|{
return|return
name|value
operator|!=
literal|0
return|;
block|}
DECL|method|LongTochar
specifier|public
specifier|static
name|char
name|LongTochar
parameter_list|(
specifier|final
name|Long
name|value
parameter_list|)
block|{
return|return
operator|(
name|char
operator|)
name|value
operator|.
name|longValue
argument_list|()
return|;
block|}
DECL|method|floatToboolean
specifier|public
specifier|static
name|boolean
name|floatToboolean
parameter_list|(
specifier|final
name|float
name|value
parameter_list|)
block|{
return|return
name|value
operator|!=
literal|0
return|;
block|}
DECL|method|floatToByte
specifier|public
specifier|static
name|Byte
name|floatToByte
parameter_list|(
specifier|final
name|float
name|value
parameter_list|)
block|{
return|return
operator|(
name|byte
operator|)
name|value
return|;
block|}
DECL|method|floatToShort
specifier|public
specifier|static
name|Short
name|floatToShort
parameter_list|(
specifier|final
name|float
name|value
parameter_list|)
block|{
return|return
operator|(
name|short
operator|)
name|value
return|;
block|}
DECL|method|floatToCharacter
specifier|public
specifier|static
name|Character
name|floatToCharacter
parameter_list|(
specifier|final
name|float
name|value
parameter_list|)
block|{
return|return
call|(
name|char
call|)
argument_list|(
name|float
argument_list|)
name|value
return|;
block|}
DECL|method|floatToInteger
specifier|public
specifier|static
name|Integer
name|floatToInteger
parameter_list|(
specifier|final
name|float
name|value
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|value
return|;
block|}
DECL|method|floatToLong
specifier|public
specifier|static
name|Long
name|floatToLong
parameter_list|(
specifier|final
name|float
name|value
parameter_list|)
block|{
return|return
operator|(
name|long
operator|)
name|value
return|;
block|}
DECL|method|floatToDouble
specifier|public
specifier|static
name|Double
name|floatToDouble
parameter_list|(
specifier|final
name|float
name|value
parameter_list|)
block|{
return|return
operator|(
name|double
operator|)
name|value
return|;
block|}
DECL|method|FloatToboolean
specifier|public
specifier|static
name|boolean
name|FloatToboolean
parameter_list|(
specifier|final
name|Float
name|value
parameter_list|)
block|{
return|return
name|value
operator|!=
literal|0
return|;
block|}
DECL|method|FloatTochar
specifier|public
specifier|static
name|char
name|FloatTochar
parameter_list|(
specifier|final
name|Float
name|value
parameter_list|)
block|{
return|return
operator|(
name|char
operator|)
name|value
operator|.
name|floatValue
argument_list|()
return|;
block|}
DECL|method|doubleToboolean
specifier|public
specifier|static
name|boolean
name|doubleToboolean
parameter_list|(
specifier|final
name|double
name|value
parameter_list|)
block|{
return|return
name|value
operator|!=
literal|0
return|;
block|}
DECL|method|doubleToByte
specifier|public
specifier|static
name|Byte
name|doubleToByte
parameter_list|(
specifier|final
name|double
name|value
parameter_list|)
block|{
return|return
operator|(
name|byte
operator|)
name|value
return|;
block|}
DECL|method|doubleToShort
specifier|public
specifier|static
name|Short
name|doubleToShort
parameter_list|(
specifier|final
name|double
name|value
parameter_list|)
block|{
return|return
operator|(
name|short
operator|)
name|value
return|;
block|}
DECL|method|doubleToCharacter
specifier|public
specifier|static
name|Character
name|doubleToCharacter
parameter_list|(
specifier|final
name|double
name|value
parameter_list|)
block|{
return|return
call|(
name|char
call|)
argument_list|(
name|double
argument_list|)
name|value
return|;
block|}
DECL|method|doubleToInteger
specifier|public
specifier|static
name|Integer
name|doubleToInteger
parameter_list|(
specifier|final
name|double
name|value
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|value
return|;
block|}
DECL|method|doubleToLong
specifier|public
specifier|static
name|Long
name|doubleToLong
parameter_list|(
specifier|final
name|double
name|value
parameter_list|)
block|{
return|return
operator|(
name|long
operator|)
name|value
return|;
block|}
DECL|method|doubleToFloat
specifier|public
specifier|static
name|Float
name|doubleToFloat
parameter_list|(
specifier|final
name|double
name|value
parameter_list|)
block|{
return|return
operator|(
name|float
operator|)
name|value
return|;
block|}
DECL|method|DoubleToboolean
specifier|public
specifier|static
name|boolean
name|DoubleToboolean
parameter_list|(
specifier|final
name|Double
name|value
parameter_list|)
block|{
return|return
name|value
operator|!=
literal|0
return|;
block|}
DECL|method|DoubleTochar
specifier|public
specifier|static
name|char
name|DoubleTochar
parameter_list|(
specifier|final
name|Double
name|value
parameter_list|)
block|{
return|return
operator|(
name|char
operator|)
name|value
operator|.
name|doubleValue
argument_list|()
return|;
block|}
comment|// although divide by zero is guaranteed, the special overflow case is not caught.
comment|// its not needed for remainder because it is not possible there.
comment|// see https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.17.2
comment|/**      * Integer divide without overflow      * @throws ArithmeticException on overflow or divide-by-zero      */
DECL|method|divideWithoutOverflow
specifier|public
specifier|static
name|int
name|divideWithoutOverflow
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
if|if
condition|(
name|x
operator|==
name|Integer
operator|.
name|MIN_VALUE
operator|&&
name|y
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"integer overflow"
argument_list|)
throw|;
block|}
return|return
name|x
operator|/
name|y
return|;
block|}
comment|/**      * Long divide without overflow      * @throws ArithmeticException on overflow or divide-by-zero      */
DECL|method|divideWithoutOverflow
specifier|public
specifier|static
name|long
name|divideWithoutOverflow
parameter_list|(
name|long
name|x
parameter_list|,
name|long
name|y
parameter_list|)
block|{
if|if
condition|(
name|x
operator|==
name|Long
operator|.
name|MIN_VALUE
operator|&&
name|y
operator|==
operator|-
literal|1L
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"long overflow"
argument_list|)
throw|;
block|}
return|return
name|x
operator|/
name|y
return|;
block|}
comment|// byte, short, and char are promoted to int for normal operations,
comment|// so the JDK exact methods are typically used, and the result has a wider range.
comment|// but compound assignments and increment/decrement operators (e.g. byte b = Byte.MAX_VALUE; b++;)
comment|// implicitly cast back to the original type: so these need to be checked against the original range.
comment|/**      * Like {@link Math#toIntExact(long)} but for byte range.      */
DECL|method|toByteExact
specifier|public
specifier|static
name|byte
name|toByteExact
parameter_list|(
name|int
name|value
parameter_list|)
block|{
name|byte
name|s
init|=
operator|(
name|byte
operator|)
name|value
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|value
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"byte overflow"
argument_list|)
throw|;
block|}
return|return
name|s
return|;
block|}
comment|/**      * Like {@link Math#toIntExact(long)} but for byte range.      */
DECL|method|toByteExact
specifier|public
specifier|static
name|byte
name|toByteExact
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|byte
name|s
init|=
operator|(
name|byte
operator|)
name|value
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|value
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"byte overflow"
argument_list|)
throw|;
block|}
return|return
name|s
return|;
block|}
comment|/**      * Like {@link Math#toIntExact(long)} but for byte range.      */
DECL|method|toByteWithoutOverflow
specifier|public
specifier|static
name|byte
name|toByteWithoutOverflow
parameter_list|(
name|float
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
argument_list|<
name|Byte
operator|.
name|MIN_VALUE
operator|||
name|value
argument_list|>
name|Byte
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"byte overflow"
argument_list|)
throw|;
block|}
return|return
operator|(
name|byte
operator|)
name|value
return|;
block|}
comment|/**      * Like {@link Math#toIntExact(long)} but for byte range.      */
DECL|method|toByteWithoutOverflow
specifier|public
specifier|static
name|byte
name|toByteWithoutOverflow
parameter_list|(
name|double
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
argument_list|<
name|Byte
operator|.
name|MIN_VALUE
operator|||
name|value
argument_list|>
name|Byte
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"byte overflow"
argument_list|)
throw|;
block|}
return|return
operator|(
name|byte
operator|)
name|value
return|;
block|}
comment|/**      * Like {@link Math#toIntExact(long)} but for short range.      */
DECL|method|toShortExact
specifier|public
specifier|static
name|short
name|toShortExact
parameter_list|(
name|int
name|value
parameter_list|)
block|{
name|short
name|s
init|=
operator|(
name|short
operator|)
name|value
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|value
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"short overflow"
argument_list|)
throw|;
block|}
return|return
name|s
return|;
block|}
comment|/**      * Like {@link Math#toIntExact(long)} but for short range.      */
DECL|method|toShortExact
specifier|public
specifier|static
name|short
name|toShortExact
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|short
name|s
init|=
operator|(
name|short
operator|)
name|value
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|value
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"short overflow"
argument_list|)
throw|;
block|}
return|return
name|s
return|;
block|}
comment|/**      * Like {@link Math#toIntExact(long)} but for short range.      */
DECL|method|toShortWithoutOverflow
specifier|public
specifier|static
name|short
name|toShortWithoutOverflow
parameter_list|(
name|float
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
argument_list|<
name|Short
operator|.
name|MIN_VALUE
operator|||
name|value
argument_list|>
name|Short
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"short overflow"
argument_list|)
throw|;
block|}
return|return
operator|(
name|short
operator|)
name|value
return|;
block|}
comment|/**      * Like {@link Math#toIntExact(long)} but for short range.      */
DECL|method|toShortExact
specifier|public
specifier|static
name|short
name|toShortExact
parameter_list|(
name|double
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
argument_list|<
name|Short
operator|.
name|MIN_VALUE
operator|||
name|value
argument_list|>
name|Short
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"short overflow"
argument_list|)
throw|;
block|}
return|return
operator|(
name|short
operator|)
name|value
return|;
block|}
comment|/**      * Like {@link Math#toIntExact(long)} but for char range.      */
DECL|method|toCharExact
specifier|public
specifier|static
name|char
name|toCharExact
parameter_list|(
name|int
name|value
parameter_list|)
block|{
name|char
name|s
init|=
operator|(
name|char
operator|)
name|value
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|value
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"char overflow"
argument_list|)
throw|;
block|}
return|return
name|s
return|;
block|}
comment|/**      * Like {@link Math#toIntExact(long)} but for char range.      */
DECL|method|toCharExact
specifier|public
specifier|static
name|char
name|toCharExact
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|char
name|s
init|=
operator|(
name|char
operator|)
name|value
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|value
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"char overflow"
argument_list|)
throw|;
block|}
return|return
name|s
return|;
block|}
comment|/**      * Like {@link Math#toIntExact(long)} but for char range.      */
DECL|method|toCharWithoutOverflow
specifier|public
specifier|static
name|char
name|toCharWithoutOverflow
parameter_list|(
name|float
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
argument_list|<
name|Character
operator|.
name|MIN_VALUE
operator|||
name|value
argument_list|>
name|Character
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"char overflow"
argument_list|)
throw|;
block|}
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
comment|/**      * Like {@link Math#toIntExact(long)} but for char range.      */
DECL|method|toCharWithoutOverflow
specifier|public
specifier|static
name|char
name|toCharWithoutOverflow
parameter_list|(
name|double
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
argument_list|<
name|Character
operator|.
name|MIN_VALUE
operator|||
name|value
argument_list|>
name|Character
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"char overflow"
argument_list|)
throw|;
block|}
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
comment|/**      * Like {@link Math#toIntExact(long)} but for int range.      */
DECL|method|toIntWithoutOverflow
specifier|public
specifier|static
name|int
name|toIntWithoutOverflow
parameter_list|(
name|float
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
argument_list|<
name|Integer
operator|.
name|MIN_VALUE
operator|||
name|value
argument_list|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"int overflow"
argument_list|)
throw|;
block|}
return|return
operator|(
name|int
operator|)
name|value
return|;
block|}
comment|/**      * Like {@link Math#toIntExact(long)} but for int range.      */
DECL|method|toIntWithoutOverflow
specifier|public
specifier|static
name|int
name|toIntWithoutOverflow
parameter_list|(
name|double
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
argument_list|<
name|Integer
operator|.
name|MIN_VALUE
operator|||
name|value
argument_list|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"int overflow"
argument_list|)
throw|;
block|}
return|return
operator|(
name|int
operator|)
name|value
return|;
block|}
comment|/**      * Like {@link Math#toIntExact(long)} but for long range.      */
DECL|method|toLongExactWithoutOverflow
specifier|public
specifier|static
name|long
name|toLongExactWithoutOverflow
parameter_list|(
name|float
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
argument_list|<
name|Long
operator|.
name|MIN_VALUE
operator|||
name|value
argument_list|>
name|Long
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"long overflow"
argument_list|)
throw|;
block|}
return|return
operator|(
name|long
operator|)
name|value
return|;
block|}
comment|/**      * Like {@link Math#toIntExact(long)} but for long range.      */
DECL|method|toLongExactWithoutOverflow
specifier|public
specifier|static
name|float
name|toLongExactWithoutOverflow
parameter_list|(
name|double
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
argument_list|<
name|Long
operator|.
name|MIN_VALUE
operator|||
name|value
argument_list|>
name|Long
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"long overflow"
argument_list|)
throw|;
block|}
return|return
operator|(
name|long
operator|)
name|value
return|;
block|}
comment|/**      * Like {@link Math#toIntExact(long)} but for float range.      */
DECL|method|toFloatWithoutOverflow
specifier|public
specifier|static
name|float
name|toFloatWithoutOverflow
parameter_list|(
name|double
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
argument_list|<
name|Float
operator|.
name|MIN_VALUE
operator|||
name|value
argument_list|>
name|Float
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"float overflow"
argument_list|)
throw|;
block|}
return|return
operator|(
name|float
operator|)
name|value
return|;
block|}
comment|/**      * Checks for overflow, result is infinite but operands are finite      * @throws ArithmeticException if overflow occurred      */
DECL|method|checkInfFloat
specifier|private
specifier|static
name|float
name|checkInfFloat
parameter_list|(
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|,
name|float
name|z
parameter_list|)
block|{
if|if
condition|(
name|Float
operator|.
name|isInfinite
argument_list|(
name|z
argument_list|)
condition|)
block|{
if|if
condition|(
name|Float
operator|.
name|isFinite
argument_list|(
name|x
argument_list|)
operator|&&
name|Float
operator|.
name|isFinite
argument_list|(
name|y
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"float overflow"
argument_list|)
throw|;
block|}
block|}
return|return
name|z
return|;
block|}
comment|/**      * Checks for NaN, result is NaN but operands are finite      * @throws ArithmeticException if overflow occurred      */
DECL|method|checkNaNFloat
specifier|private
specifier|static
name|float
name|checkNaNFloat
parameter_list|(
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|,
name|float
name|z
parameter_list|)
block|{
if|if
condition|(
name|Float
operator|.
name|isNaN
argument_list|(
name|z
argument_list|)
condition|)
block|{
if|if
condition|(
name|Float
operator|.
name|isFinite
argument_list|(
name|x
argument_list|)
operator|&&
name|Float
operator|.
name|isFinite
argument_list|(
name|y
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"NaN"
argument_list|)
throw|;
block|}
block|}
return|return
name|z
return|;
block|}
comment|/**      * Checks for NaN, result is infinite but operands are finite      * @throws ArithmeticException if overflow occurred      */
DECL|method|checkInfDouble
specifier|private
specifier|static
name|double
name|checkInfDouble
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|,
name|double
name|z
parameter_list|)
block|{
if|if
condition|(
name|Double
operator|.
name|isInfinite
argument_list|(
name|z
argument_list|)
condition|)
block|{
if|if
condition|(
name|Double
operator|.
name|isFinite
argument_list|(
name|x
argument_list|)
operator|&&
name|Double
operator|.
name|isFinite
argument_list|(
name|y
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"double overflow"
argument_list|)
throw|;
block|}
block|}
return|return
name|z
return|;
block|}
comment|/**      * Checks for NaN, result is NaN but operands are finite      * @throws ArithmeticException if overflow occurred      */
DECL|method|checkNaNDouble
specifier|private
specifier|static
name|double
name|checkNaNDouble
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|,
name|double
name|z
parameter_list|)
block|{
if|if
condition|(
name|Double
operator|.
name|isNaN
argument_list|(
name|z
argument_list|)
condition|)
block|{
if|if
condition|(
name|Double
operator|.
name|isFinite
argument_list|(
name|x
argument_list|)
operator|&&
name|Double
operator|.
name|isFinite
argument_list|(
name|y
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"NaN"
argument_list|)
throw|;
block|}
block|}
return|return
name|z
return|;
block|}
comment|/**      * Adds two floats but throws {@code ArithmeticException}      * if the result overflows.      */
DECL|method|addWithoutOverflow
specifier|public
specifier|static
name|float
name|addWithoutOverflow
parameter_list|(
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|)
block|{
return|return
name|checkInfFloat
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|x
operator|+
name|y
argument_list|)
return|;
block|}
comment|/**      * Adds two doubles but throws {@code ArithmeticException}      * if the result overflows.      */
DECL|method|addWithoutOverflow
specifier|public
specifier|static
name|double
name|addWithoutOverflow
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|)
block|{
return|return
name|checkInfDouble
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|x
operator|+
name|y
argument_list|)
return|;
block|}
comment|/**      * Subtracts two floats but throws {@code ArithmeticException}      * if the result overflows.      */
DECL|method|subtractWithoutOverflow
specifier|public
specifier|static
name|float
name|subtractWithoutOverflow
parameter_list|(
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|)
block|{
return|return
name|checkInfFloat
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|x
operator|-
name|y
argument_list|)
return|;
block|}
comment|/**      * Subtracts two doubles but throws {@code ArithmeticException}      * if the result overflows.      */
DECL|method|subtractWithoutOverflow
specifier|public
specifier|static
name|double
name|subtractWithoutOverflow
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|)
block|{
return|return
name|checkInfDouble
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|x
operator|-
name|y
argument_list|)
return|;
block|}
comment|/**      * Multiplies two floats but throws {@code ArithmeticException}      * if the result overflows.      */
DECL|method|multiplyWithoutOverflow
specifier|public
specifier|static
name|float
name|multiplyWithoutOverflow
parameter_list|(
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|)
block|{
return|return
name|checkInfFloat
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|x
operator|*
name|y
argument_list|)
return|;
block|}
comment|/**      * Multiplies two doubles but throws {@code ArithmeticException}      * if the result overflows.      */
DECL|method|multiplyWithoutOverflow
specifier|public
specifier|static
name|double
name|multiplyWithoutOverflow
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|)
block|{
return|return
name|checkInfDouble
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|x
operator|*
name|y
argument_list|)
return|;
block|}
comment|/**      * Divides two floats but throws {@code ArithmeticException}      * if the result overflows, or would create NaN from finite      * inputs ({@code x == 0, y == 0})      */
DECL|method|divideWithoutOverflow
specifier|public
specifier|static
name|float
name|divideWithoutOverflow
parameter_list|(
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|)
block|{
return|return
name|checkNaNFloat
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|checkInfFloat
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|x
operator|/
name|y
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Divides two doubles but throws {@code ArithmeticException}      * if the result overflows, or would create NaN from finite      * inputs ({@code x == 0, y == 0})      */
DECL|method|divideWithoutOverflow
specifier|public
specifier|static
name|double
name|divideWithoutOverflow
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|)
block|{
return|return
name|checkNaNDouble
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|checkInfDouble
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|x
operator|/
name|y
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Takes remainder two floats but throws {@code ArithmeticException}      * if the result would create NaN from finite inputs ({@code y == 0})      */
DECL|method|remainderWithoutOverflow
specifier|public
specifier|static
name|float
name|remainderWithoutOverflow
parameter_list|(
name|float
name|x
parameter_list|,
name|float
name|y
parameter_list|)
block|{
return|return
name|checkNaNFloat
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|x
operator|%
name|y
argument_list|)
return|;
block|}
comment|/**      * Divides two doubles but throws {@code ArithmeticException}      * if the result would create NaN from finite inputs ({@code y == 0})      */
DECL|method|remainderWithoutOverflow
specifier|public
specifier|static
name|double
name|remainderWithoutOverflow
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|)
block|{
return|return
name|checkNaNDouble
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|x
operator|%
name|y
argument_list|)
return|;
block|}
DECL|method|checkEquals
specifier|public
specifier|static
name|boolean
name|checkEquals
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|!=
literal|null
operator|&&
name|right
operator|!=
literal|null
condition|)
block|{
return|return
name|left
operator|.
name|equals
argument_list|(
name|right
argument_list|)
return|;
block|}
return|return
name|left
operator|==
literal|null
operator|&&
name|right
operator|==
literal|null
return|;
block|}
DECL|method|Utility
specifier|private
name|Utility
parameter_list|()
block|{}
block|}
end_class

end_unit

